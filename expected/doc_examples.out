-- Test: Documentation Examples
-- Purpose: Verify all SQL examples in user documentation work correctly
-- This file ensures documentation examples remain accurate as the codebase evolves.
--
-- Constitution requirement: All SQL code blocks in documentation (README.md, doc/*.md)
-- MUST have corresponding regression tests in this file.
-- Load extension (suppress notice about already exists when run after other tests)
SET client_min_messages = warning;
CREATE EXTENSION IF NOT EXISTS pg_num2int_direct_comp;
SET client_min_messages = notice;
-- ============================================================================
-- README.md: The Problem - Implicit Casting Produces Wrong Results (~line 74)
-- ============================================================================
-- PostgreSQL's DEFAULT behavior (Mathematically WRONG):
-- With extension: exact comparison detects the mismatch
SELECT 16777217::int4 = 16777216::float4 AS should_be_false;
 should_be_false 
-----------------
 f
(1 row)

-- ============================================================================
-- README.md: User lookup example (~line 85)
-- This demonstrates a problem the extension CANNOT fix: when the application
-- passes a float4 parameter, the value is already corrupted before comparison.
-- float4 cannot represent 16777217, so it becomes 16777216.0 before PostgreSQL
-- even sees the comparison.
-- ============================================================================
CREATE TEMPORARY TABLE users(id int4 PRIMARY KEY, name text);
INSERT INTO users VALUES (16777216, 'Alice'), (16777217, 'Bob');
-- This shows the PROBLEM: float4 parameter is already corrupted
-- 16777217::float4 becomes 16777216.0, so Alice is returned (WRONG!)
-- The extension cannot fix this - the value is lost before comparison
PREPARE find_user(float4) AS SELECT * FROM users WHERE id = $1;
EXECUTE find_user(16777217);  -- Returns Alice (id=16777216), not Bob!
    id    | name  
----------+-------
 16777216 | Alice
(1 row)

DEALLOCATE find_user;
-- SOLUTION: Use numeric parameter type instead of float4
-- numeric can exactly represent any integer, so Bob is correctly found
PREPARE find_user_numeric(numeric) AS SELECT * FROM users WHERE id = $1;
EXECUTE find_user_numeric(16777217);  -- Correctly returns Bob!
    id    | name 
----------+------
 16777217 | Bob
(1 row)

DEALLOCATE find_user_numeric;
DROP TABLE users;
-- ============================================================================
-- README.md: Transitive Equality Violations (~line 107)
-- Stock PostgreSQL violates transitivity with int8/float8 at 2^53 boundary.
-- We test both stock behavior (extension disabled) and extension behavior.
-- ============================================================================
-- First, test STOCK PostgreSQL behavior (matches README examples)
DROP EXTENSION pg_num2int_direct_comp;
NOTICE:  pg_num2int_direct_comp: cleaned up operator family entries
SELECT 9007199254740993::int8 = 9007199254740993::float8 AS stock_a_eq_b;  -- TRUE (both become same float8)
 stock_a_eq_b 
--------------
 t
(1 row)

SELECT 9007199254740993::float8 = 9007199254740992::int8 AS stock_b_eq_c;  -- TRUE (float8 already rounded)
 stock_b_eq_c 
--------------
 t
(1 row)

SELECT 9007199254740993::int8 = 9007199254740992::int8 AS stock_a_eq_c;    -- FALSE
 stock_a_eq_c 
--------------
 f
(1 row)

-- Transitivity violated: a=b, b=c, but a≠c
-- Reinstall extension and test fixed behavior
CREATE EXTENSION pg_num2int_direct_comp;
SELECT 9007199254740993::int8 = 9007199254740993::float8 AS ext_a_eq_b;    -- FALSE (extension detects mismatch)
 ext_a_eq_b 
------------
 f
(1 row)

SELECT 9007199254740993::float8 = 9007199254740992::int8 AS ext_b_eq_c;    -- TRUE (float8 already 9007199254740992.0)
 ext_b_eq_c 
------------
 t
(1 row)

SELECT 9007199254740993::int8 = 9007199254740992::int8 AS ext_a_eq_c;      -- FALSE (same-type, no change)
 ext_a_eq_c 
------------
 f
(1 row)

-- Extension fixes first comparison; second is TRUE because float8 literal is not rounded
-- ============================================================================
-- README.md: Implicit cast via float8 arithmetic (~line 119)
-- Adding a float8 column promotes integers to float8, causing precision loss
-- ============================================================================
-- This demonstrates why PostgreSQL cannot infer a=c from a=f(b) AND f(b)=c
WITH vals(a, b, c, d) AS (
    VALUES (9007199254740993::int8,   -- A: cannot be exactly represented in float8
            9007199254740993::int8,   -- B: same as A
            9007199254740992::int8,   -- C: one less (exact in float8)
            0.0::float8)              -- D: zero, but float8 type forces promotion
)
SELECT a, b, c,
    a = (b + d) AS a_eq_bplusd,    -- TRUE: b+d promotes to float8, rounds
    (b + d) = c AS bplusd_eq_c,    -- TRUE: 9007199254740992.0 = 9007199254740992
    a = c AS a_eq_c                -- FALSE: 9007199254740993 ≠ 9007199254740992
FROM vals
WHERE a = (b + d) AND (b + d) = c;
 a | b | c | a_eq_bplusd | bplusd_eq_c | a_eq_c 
---+---+---+-------------+-------------+--------
(0 rows)

-- Row IS returned! If PostgreSQL incorrectly inferred a=c, this row would be filtered out.
-- ============================================================================
-- README.md: Index Optimization via Support Functions (~line 213)
-- Single-table lookup and self-join with numeric parameter
-- ============================================================================
CREATE TEMPORARY TABLE products (
    id INT4 PRIMARY KEY,
    parent INT4,
    name TEXT
);
CREATE INDEX idx_products_parent ON products(parent);
-- Insert sample hierarchical data
INSERT INTO products VALUES
    (1, NULL, 'Electronics'),
    (2, 1, 'Phones'),
    (3, 1, 'Laptops'),
    (42, 2, 'iPhone'),
    (43, 2, 'Android'),
    (100, 3, 'MacBook');
ANALYZE products;
-- Prepared statement with numeric parameter (common API pattern)
PREPARE find_product(numeric) AS SELECT * FROM products WHERE id = $1;
PREPARE find_parent(numeric) AS
    SELECT p.name AS parent_name
    FROM products p, products c
    WHERE p.id = c.parent AND c.id = $1;
-- Test single-table lookup uses primary key index
EXPLAIN (COSTS OFF) EXECUTE find_product(42);
      QUERY PLAN      
----------------------
 Seq Scan on products
   Filter: (id = 42)
(2 rows)

-- Verify result
SELECT * FROM products WHERE id = 42::numeric;
 id | parent |  name  
----+--------+--------
 42 |      2 | iPhone
(1 row)

-- Test self-join uses indexes on both tables
EXPLAIN (COSTS OFF) EXECUTE find_parent(42);
             QUERY PLAN             
------------------------------------
 Hash Join
   Hash Cond: (p.id = c.parent)
   ->  Seq Scan on products p
   ->  Hash
         ->  Seq Scan on products c
               Filter: (id = 42)
(6 rows)

-- Verify result
SELECT p.name AS parent_name
FROM products p, products c
WHERE p.id = c.parent AND c.id = 42::numeric;
 parent_name 
-------------
 Phones
(1 row)

-- Clean up
DEALLOCATE find_product;
DEALLOCATE find_parent;
DROP TABLE products;
-- ============================================================================
-- README.md: Quick Start Example 1 - Detecting Float Precision Loss (~line 359)
-- The extension detects when int4 value differs from float4 representation.
-- 16777217::float4 rounds to 16777216.0, so:
-- - 16777216::int4 = 16777217::float4 → TRUE (both are 16777216)
-- - 16777217::int4 = 16777217::float4 → FALSE (16777217 ≠ 16777216.0)
-- ============================================================================
-- 16777217::float4 rounds down to 16777216.0
SELECT 16777216::int4 = 16777217::float4 AS both_are_16777216;  -- TRUE
 both_are_16777216 
-------------------
 t
(1 row)

SELECT 16777217::int4 = 16777217::float4 AS detects_mismatch;   -- FALSE (extension detects it!)
 detects_mismatch 
------------------
 f
(1 row)

-- ============================================================================
-- README.md: Quick Start Example 2 - Planner Transitivity Inference (~line 383)
-- ============================================================================
-- The query planner can infer transitive relationships across types for index optimization
CREATE TEMPORARY TABLE ex2_orders (id SERIAL, customer_id NUMERIC);
CREATE TEMPORARY TABLE ex2_customers (id INT4 PRIMARY KEY, name TEXT);
CREATE INDEX ON ex2_orders(customer_id);
INSERT INTO ex2_orders (customer_id) SELECT g::numeric FROM generate_series(1, 100) g;
INSERT INTO ex2_customers SELECT g, 'Customer ' || g FROM generate_series(1, 100) g;
ANALYZE ex2_orders;
ANALYZE ex2_customers;
-- Query with cross-type join: orders.customer_id (numeric) = customers.id (int4)
PREPARE find_orders(int4) AS
  SELECT o.* FROM ex2_orders o JOIN ex2_customers c ON o.customer_id = c.id WHERE c.id = $1;
-- With extension: planner infers o.customer_id = $1 across types, enabling index scan
-- The Index Cond should show (customer_id = 42), not (customer_id = (c.id)::numeric)
SET enable_seqscan = off;
EXPLAIN (COSTS OFF) EXECUTE find_orders(42);
                            QUERY PLAN                             
-------------------------------------------------------------------
 Nested Loop
   ->  Index Only Scan using ex2_customers_pkey on ex2_customers c
         Index Cond: (id = 42)
   ->  Index Scan using ex2_orders_customer_id_idx on ex2_orders o
         Index Cond: (customer_id = c.id)
(5 rows)

RESET enable_seqscan;
DEALLOCATE find_orders;
DROP TABLE ex2_orders;
DROP TABLE ex2_customers;
-- ============================================================================
-- README.md: Quick Start Example 3 - Index-Optimized Queries (~line 410)
-- ============================================================================
CREATE TEMPORARY TABLE measurements (id SERIAL, value INT4);
CREATE INDEX ON measurements(value);
INSERT INTO measurements (value) SELECT generate_series(1, 1000);
ANALYZE measurements;
-- Uses index efficiently (no cast on indexed column)
EXPLAIN (COSTS OFF) SELECT * FROM measurements WHERE value = 500::numeric;
                       QUERY PLAN                        
---------------------------------------------------------
 Index Scan using measurements_value_idx on measurements
   Index Cond: (value = 500)
(2 rows)

-- ============================================================================
-- README.md: Quick Start Example 4 - Fractional Comparisons (~line 422)
-- ============================================================================
-- Fractional values never equal integers
SELECT 10::int4 = 10.5::numeric AS should_be_false;
 should_be_false 
-----------------
 f
(1 row)

SELECT 10::int4 < 10.5::numeric AS should_be_true;
 should_be_true 
----------------
 t
(1 row)

-- ============================================================================
-- README.md: Quick Start Example 5 - Hash Joins for Large Tables (~line 430)
-- ============================================================================
-- Hash joins work automatically for large table joins
CREATE TEMPORARY TABLE ex5_sales (id SERIAL, amount NUMERIC(10,2));
CREATE TEMPORARY TABLE ex5_targets (id SERIAL, threshold INT4);
INSERT INTO ex5_sales SELECT generate_series(1, 1000), (random() * 1000)::numeric(10,2);
INSERT INTO ex5_targets SELECT generate_series(1, 1000), (random() * 1000)::int4;
ANALYZE ex5_sales;
ANALYZE ex5_targets;
-- Planner can choose hash join for large equijoin (depends on cost estimates)
EXPLAIN (COSTS OFF) SELECT COUNT(*) FROM ex5_sales s JOIN ex5_targets t ON s.amount = t.threshold;
                 QUERY PLAN                  
---------------------------------------------
 Aggregate
   ->  Hash Join
         Hash Cond: (t.threshold = s.amount)
         ->  Seq Scan on ex5_targets t
         ->  Hash
               ->  Seq Scan on ex5_sales s
(6 rows)

DROP TABLE ex5_sales;
DROP TABLE ex5_targets;
-- ============================================================================
-- README.md: Quick Start Example 6 - Type Aliases (~line 444)
-- ============================================================================
-- Serial types work automatically
CREATE TEMPORARY TABLE ex6_users (id SERIAL, score INT4);
INSERT INTO ex6_users (score) VALUES (100);
SELECT * FROM ex6_users WHERE id = 1.0::numeric;  -- Uses exact comparison
 id | score 
----+-------
  1 |   100
(1 row)

-- Decimal type works automatically (decimal is alias for numeric)
SELECT 10::int4 = 10.0::decimal AS decimal_alias_test;
 decimal_alias_test 
--------------------
 t
(1 row)

DROP TABLE ex6_users;
-- ============================================================================
-- README.md: Quick Start Example 7 - Impossible Predicate Detection (~line 455)
-- ============================================================================
-- Impossible predicate detection: integer can never equal fractional value
EXPLAIN (COSTS OFF) SELECT * FROM measurements WHERE value = 10.5::numeric;
        QUERY PLAN        
--------------------------
 Result
   One-Time Filter: false
(2 rows)

-- Exact match transformation: uses native integer operator
EXPLAIN (COSTS OFF) SELECT * FROM measurements WHERE value = 100::numeric;
                       QUERY PLAN                        
---------------------------------------------------------
 Index Scan using measurements_value_idx on measurements
   Index Cond: (value = 100)
(2 rows)

DROP TABLE measurements;
-- ============================================================================
-- doc/operator-reference.md: Precision Boundaries - float4 example
-- Same as above: 16777217::float4 rounds to 16777216.0
-- ============================================================================
-- 16777217::float4 rounds to 16777216.0, so comparison with 16777216 is TRUE
SELECT 16777216::bigint = 16777217::float4 AS both_are_16777216;  -- TRUE
 both_are_16777216 
-------------------
 t
(1 row)

SELECT 16777217::bigint = 16777217::float4 AS detects_mismatch;   -- FALSE (extension detects it!)
 detects_mismatch 
------------------
 f
(1 row)

-- ============================================================================
-- doc/operator-reference.md: Index Usage example
-- ============================================================================
CREATE TEMPORARY TABLE large_table (id INT4 PRIMARY KEY, data TEXT);
INSERT INTO large_table SELECT g, 'data' || g FROM generate_series(1, 1000) g;
ANALYZE large_table;
-- Uses index (fast)
EXPLAIN (COSTS OFF) SELECT * FROM large_table WHERE id = 12345::numeric;
                    QUERY PLAN                    
--------------------------------------------------
 Index Scan using large_table_pkey on large_table
   Index Cond: (id = 12345)
(2 rows)

EXPLAIN (COSTS OFF) SELECT * FROM large_table WHERE id <= 100::float8;
                    QUERY PLAN                    
--------------------------------------------------
 Index Scan using large_table_pkey on large_table
   Index Cond: (id <= 100)
(2 rows)

DROP TABLE large_table;
-- ============================================================================
-- doc/operator-reference.md: Commutator Operators
-- ============================================================================
-- Both directions work identically
SELECT 10::int4 = 100.0::numeric AS forward_eq;
 forward_eq 
------------
 f
(1 row)

SELECT 100.0::numeric = 10::int4 AS reverse_eq;
 reverse_eq 
------------
 f
(1 row)

-- Works with all operators
SELECT 10::int4 < 20.5::float8 AS forward_lt;
 forward_lt 
------------
 t
(1 row)

SELECT 20.5::float8 > 10::int4 AS reverse_gt;
 reverse_gt 
------------
 t
(1 row)

-- ============================================================================
-- doc/operator-reference.md: Special Cases - NULL Handling
-- ============================================================================
SELECT NULL::int4 = 10.0::numeric AS null_lhs;
 null_lhs 
----------
 
(1 row)

SELECT 10::int4 = NULL::numeric AS null_rhs;
 null_rhs 
----------
 
(1 row)

SELECT NULL::int4 = NULL::numeric AS both_null;
 both_null 
-----------
 
(1 row)

-- ============================================================================
-- doc/operator-reference.md: Special Cases - NaN and Infinity
-- ============================================================================
-- NaN comparisons with integers always return false for equality
SELECT 'NaN'::float4 = 10::int4 AS nan_eq_int;
 nan_eq_int 
------------
 f
(1 row)

SELECT 'NaN'::float8 = 10::int8 AS nan_eq_bigint;
 nan_eq_bigint 
---------------
 f
(1 row)

-- NaN sorts higher than everything (including max integers)
SELECT 2147483647::int4 < 'NaN'::float4 AS max_int4_lt_nan;
 max_int4_lt_nan 
-----------------
 t
(1 row)

-- Infinity comparisons
SELECT 'Infinity'::float4 > 10::int4 AS pos_inf_gt;
 pos_inf_gt 
------------
 t
(1 row)

SELECT '-Infinity'::float8 < 10::int8 AS neg_inf_lt;
 neg_inf_lt 
------------
 t
(1 row)

-- ============================================================================
-- doc/operator-reference.md: Special Cases - Fractional Parts
-- ============================================================================
SELECT 10.0::numeric = 10::int4 AS no_frac_eq;
 no_frac_eq 
------------
 t
(1 row)

SELECT 10.5::numeric = 10::int4 AS has_frac_eq;
 has_frac_eq 
-------------
 f
(1 row)

SELECT 10.001::numeric = 10::int4 AS small_frac_eq;
 small_frac_eq 
---------------
 f
(1 row)

-- ============================================================================
-- doc/operator-reference.md: Query Optimization - Impossible Predicate Detection (FR-015)
-- ============================================================================
CREATE TEMPORARY TABLE fr015_test (int_col INT4);
INSERT INTO fr015_test SELECT generate_series(1, 100);
ANALYZE fr015_test;
-- int_col can never equal 10.5 (fractional value)
EXPLAIN (COSTS OFF) SELECT * FROM fr015_test WHERE int_col = 10.5::numeric;
        QUERY PLAN        
--------------------------
 Result
   One-Time Filter: false
(2 rows)

-- ============================================================================
-- doc/operator-reference.md: Query Optimization - Exact Match Transformation (FR-016)
-- ============================================================================
CREATE INDEX ON fr015_test(int_col);
ANALYZE fr015_test;
-- 100::numeric exactly equals 100::int4
EXPLAIN (COSTS OFF) SELECT * FROM fr015_test WHERE int_col = 100::numeric;
        QUERY PLAN         
---------------------------
 Seq Scan on fr015_test
   Filter: (int_col = 100)
(2 rows)

DROP TABLE fr015_test;
-- ============================================================================
-- doc/operator-reference.md: HASHES property example (~line 130)
-- ============================================================================
CREATE TEMPORARY TABLE hash_a (int_col INT4);
CREATE TEMPORARY TABLE hash_b (numeric_col NUMERIC);
INSERT INTO hash_a SELECT generate_series(1, 1000);
INSERT INTO hash_b SELECT generate_series(1, 1000)::numeric;
ANALYZE hash_a;
ANALYZE hash_b;
-- Can use Hash Join strategy
EXPLAIN (COSTS OFF) SELECT * FROM hash_a a JOIN hash_b b ON a.int_col = b.numeric_col WHERE a.int_col < 100;
                QUERY PLAN                
------------------------------------------
 Hash Join
   Hash Cond: (b.numeric_col = a.int_col)
   ->  Seq Scan on hash_b b
   ->  Hash
         ->  Seq Scan on hash_a a
               Filter: (int_col < 100)
(6 rows)

DROP TABLE hash_a;
DROP TABLE hash_b;
-- ============================================================================
-- doc/operator-reference.md: Support function example (~line 163)
-- ============================================================================
CREATE TEMPORARY TABLE support_test (intkey1 INT4, intkey2 INT4);
CREATE INDEX ON support_test(intkey1, intkey2);
INSERT INTO support_test SELECT i, i FROM generate_series(1, 1000) i;
ANALYZE support_test;
-- Query with constants - num2int_support transforms predicates
EXPLAIN (COSTS OFF) SELECT * FROM support_test
    WHERE intkey1 = 100.0::numeric AND intkey2 > 10.5::numeric;
                               QUERY PLAN                               
------------------------------------------------------------------------
 Index Only Scan using support_test_intkey1_intkey2_idx on support_test
   Index Cond: ((intkey1 = 100) AND (intkey2 >= 11))
(2 rows)

DROP TABLE support_test;
-- ============================================================================
-- doc/operator-reference.md: Precision Boundaries - float4 (~line 195)
-- ============================================================================
SELECT 16777216::int4 = 16777216::float4 AS within_range;
 within_range 
--------------
 t
(1 row)

SELECT 16777217::int4 = 16777217::float4 AS beyond_range;
 beyond_range 
--------------
 f
(1 row)

-- ============================================================================
-- doc/operator-reference.md: Precision Boundaries - float8 (~line 205)
-- ============================================================================
SELECT 9007199254740992::int8 = 9007199254740992::float8 AS within_range;
 within_range 
--------------
 t
(1 row)

SELECT 9007199254740993::int8 = 9007199254740993::float8 AS beyond_range;
 beyond_range 
--------------
 f
(1 row)

-- ============================================================================
-- doc/installation.md: Verify Installation (~line 68)
-- ============================================================================
-- Check extension is loaded
\dx pg_num2int_direct_comp
                                        List of installed extensions
          Name          | Version | Schema |                          Description                           
------------------------+---------+--------+----------------------------------------------------------------
 pg_num2int_direct_comp | 1.0.0   | public | Exact comparison operators for numeric/float and integer types
(1 row)

-- Test precision loss detection (stock PostgreSQL returns true for both)
SELECT 16777216::int4 = 16777217::float4;  -- true (float4 rounds to 16777216)
 ?column? 
----------
 t
(1 row)

SELECT 16777217::int4 = 16777217::float4;  -- false (extension detects mismatch!)
 ?column? 
----------
 f
(1 row)

-- ============================================================================
-- README.md: Configuration Examples (~line 540)
-- ============================================================================
-- Check current setting
SHOW pg_num2int_direct_comp.enable_support_functions;
 pg_num2int_direct_comp.enable_support_functions 
-------------------------------------------------
 on
(1 row)

-- Create test table for optimization verification
CREATE TEMPORARY TABLE config_test (integer_column int4);
INSERT INTO config_test VALUES (10);
-- Test with optimization disabled
SET pg_num2int_direct_comp.enable_support_functions = off;
EXPLAIN (COSTS off) SELECT * FROM config_test WHERE 10.0::float8 = integer_column;
                     QUERY PLAN                      
-----------------------------------------------------
 Seq Scan on config_test
   Filter: ('10'::double precision = integer_column)
(2 rows)

-- Test with optimization enabled
SET pg_num2int_direct_comp.enable_support_functions = on;
EXPLAIN (COSTS off) SELECT * FROM config_test WHERE 10.0::float8 = integer_column;
           QUERY PLAN            
---------------------------------
 Seq Scan on config_test
   Filter: (integer_column = 10)
(2 rows)

-- Cleanup
DROP TABLE config_test;
