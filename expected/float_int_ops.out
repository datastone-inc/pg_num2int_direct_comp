-- Test exact comparison operators for float Ã— integer combinations
-- Includes precision boundary tests for float4 and float8
-- Load extension
CREATE EXTENSION IF NOT EXISTS pg_num2int_direct_comp;
NOTICE:  extension "pg_num2int_direct_comp" already exists, skipping
-- Test 1: Basic equality - float with no fractional part
SELECT 10::float4 = 10::int2 AS "float4=int2_exact";
 float4=int2_exact 
-------------------
 t
(1 row)

SELECT 10::float4 = 10::int4 AS "float4=int4_exact";
 float4=int4_exact 
-------------------
 t
(1 row)

SELECT 10::float4 = 10::int8 AS "float4=int8_exact";
 float4=int8_exact 
-------------------
 t
(1 row)

SELECT 10::float8 = 10::int2 AS "float8=int2_exact";
 float8=int2_exact 
-------------------
 t
(1 row)

SELECT 10::float8 = 10::int4 AS "float8=int4_exact";
 float8=int4_exact 
-------------------
 t
(1 row)

SELECT 10::float8 = 10::int8 AS "float8=int8_exact";
 float8=int8_exact 
-------------------
 t
(1 row)

-- Test 2: Fractional values never equal integers
SELECT 10.5::float4 = 10::int2 AS "float4_frac=int2_false";
 float4_frac=int2_false 
------------------------
 f
(1 row)

SELECT 10.5::float4 = 10::int4 AS "float4_frac=int4_false";
 float4_frac=int4_false 
------------------------
 f
(1 row)

SELECT 10.5::float8 = 10::int8 AS "float8_frac=int8_false";
 float8_frac=int8_false 
------------------------
 f
(1 row)

-- Test 3: CRITICAL - float4 precision boundary at 2^24 (16,777,216)
-- float4 can exactly represent integers up to 2^24
SELECT 16777216::float4 = 16777216::int4 AS "float4=int4_at_limit_true";
 float4=int4_at_limit_true 
---------------------------
 t
(1 row)

-- Beyond 2^24, float4 loses precision for ODD numbers (this is the key test case)
SELECT 16777217::float4 = 16777217::int4 AS "float4=int4_beyond_limit_FALSE";
 float4=int4_beyond_limit_FALSE 
--------------------------------
 f
(1 row)

SELECT 16777219::float4 = 16777219::int4 AS "float4=int4_beyond_limit_FALSE2";
 float4=int4_beyond_limit_FALSE2 
---------------------------------
 f
(1 row)

-- Test 4: float8 precision boundary at 2^53 (within int8 but testable with int4)
SELECT 9007199254740992::float8 = 9007199254740992::int8 AS "float8=int8_at_limit_true";
 float8=int8_at_limit_true 
---------------------------
 t
(1 row)

SELECT 9007199254740993::float8 = 9007199254740993::int8 AS "float8=int8_beyond_limit_FALSE";
 float8=int8_beyond_limit_FALSE 
--------------------------------
 f
(1 row)

-- Test 5: Inequality operators with floats
SELECT 10::float4 <> 5::int2 AS "float4<>int2_diff";
 float4<>int2_diff 
-------------------
 t
(1 row)

SELECT 10::float4 <> 5::int4 AS "float4<>int4_diff";
 float4<>int4_diff 
-------------------
 t
(1 row)

SELECT 10::float8 <> 5::int8 AS "float8<>int8_diff";
 float8<>int8_diff 
-------------------
 t
(1 row)

-- Test 6: Inequality with fractional part
SELECT 10.1::float4 <> 10::int4 AS "float4_frac<>int4";
 float4_frac<>int4 
-------------------
 t
(1 row)

SELECT 10.1::float8 <> 10::int8 AS "float8_frac<>int8";
 float8_frac<>int8 
-------------------
 t
(1 row)

-- Test 7: Negative values
SELECT (-5)::float4 = (-5)::int2 AS "float4_neg=int2";
 float4_neg=int2 
-----------------
 t
(1 row)

SELECT (-5)::float4 = (-5)::int4 AS "float4_neg=int4";
 float4_neg=int4 
-----------------
 t
(1 row)

SELECT (-5)::float8 = (-5)::int8 AS "float8_neg=int8";
 float8_neg=int8 
-----------------
 t
(1 row)

-- Test 8: Zero
SELECT 0::float4 = 0::int2 AS "float4_zero=int2";
 float4_zero=int2 
------------------
 t
(1 row)

SELECT 0::float4 = 0::int4 AS "float4_zero=int4";
 float4_zero=int4 
------------------
 t
(1 row)

SELECT 0::float8 = 0::int8 AS "float8_zero=int8";
 float8_zero=int8 
------------------
 t
(1 row)

-- Test 9: Commutative property (will be fixed in Phase 4 - operator shells issue)
-- SELECT 10::int2 = 10::float4 AS "int2=float4_commute";
-- SELECT 10::int4 = 10::float8 AS "int4=float8_commute";
-- Workaround: Use float on left for now
SELECT 10::float4 = 10::int2 AS "float4=int2_commute";
 float4=int2_commute 
---------------------
 t
(1 row)

SELECT 10::float8 = 10::int4 AS "float8=int4_commute";
 float8=int4_commute 
---------------------
 t
(1 row)

-- Test 10: Real type (alias for float4)
SELECT 10::real = 10::int4 AS "real=int4";
 real=int4 
-----------
 t
(1 row)

SELECT 10.5::real <> 10::int4 AS "real_frac<>int4";
 real_frac<>int4 
-----------------
 t
(1 row)

-- Test 11: Double precision type (alias for float8)
SELECT 10::"double precision" = 10::int8 AS "double=int8";
ERROR:  type "double precision" does not exist
LINE 1: SELECT 10::"double precision" = 10::int8 AS "double=int8";
                   ^
SELECT 10.5::"double precision" <> 10::int8 AS "double_frac<>int8";
ERROR:  type "double precision" does not exist
LINE 1: SELECT 10.5::"double precision" <> 10::int8 AS "double_frac<...
                     ^
-- Test 12: NaN handling (NaN never equals anything)
SELECT 'NaN'::float4 = 10::int4 AS "NaN_float4=int4_false";
 NaN_float4=int4_false 
-----------------------
 f
(1 row)

SELECT 'NaN'::float8 = 10::int8 AS "NaN_float8=int8_false";
 NaN_float8=int8_false 
-----------------------
 f
(1 row)

SELECT 'NaN'::float4 <> 10::int4 AS "NaN_float4<>int4_true";
 NaN_float4<>int4_true 
-----------------------
 t
(1 row)

-- Test 13: Infinity handling
SELECT 'Infinity'::float4 = 10::int4 AS "Inf_float4=int4_false";
 Inf_float4=int4_false 
-----------------------
 f
(1 row)

SELECT '-Infinity'::float8 = 10::int8 AS "NegInf_float8=int8_false";
 NegInf_float8=int8_false 
--------------------------
 f
(1 row)

SELECT 'Infinity'::float4 <> 10::int4 AS "Inf_float4<>int4_true";
 Inf_float4<>int4_true 
-----------------------
 t
(1 row)

-- ============================================================================
-- Range Comparison Tests (<, >, <=, >=)
-- ============================================================================
-- Test 14: Less than operator (<) with float4
SELECT 5::float4 < 10::int2 AS "float4_lt_int2_true";
 float4_lt_int2_true 
---------------------
 t
(1 row)

SELECT 10::float4 < 10::int2 AS "float4_lt_int2_equal_false";
 float4_lt_int2_equal_false 
----------------------------
 f
(1 row)

SELECT 15::float4 < 10::int2 AS "float4_lt_int2_false";
 float4_lt_int2_false 
----------------------
 f
(1 row)

SELECT 5::float4 < 10::int4 AS "float4_lt_int4_true";
 float4_lt_int4_true 
---------------------
 t
(1 row)

SELECT 10::float4 < 10::int4 AS "float4_lt_int4_equal_false";
 float4_lt_int4_equal_false 
----------------------------
 f
(1 row)

SELECT 15::float4 < 10::int4 AS "float4_lt_int4_false";
 float4_lt_int4_false 
----------------------
 f
(1 row)

SELECT 5::float4 < 10::int8 AS "float4_lt_int8_true";
 float4_lt_int8_true 
---------------------
 t
(1 row)

SELECT 10::float4 < 10::int8 AS "float4_lt_int8_equal_false";
 float4_lt_int8_equal_false 
----------------------------
 f
(1 row)

SELECT 15::float4 < 10::int8 AS "float4_lt_int8_false";
 float4_lt_int8_false 
----------------------
 f
(1 row)

-- Test 15: Less than operator (<) with float8
SELECT 5::float8 < 10::int2 AS "float8_lt_int2_true";
 float8_lt_int2_true 
---------------------
 t
(1 row)

SELECT 10::float8 < 10::int2 AS "float8_lt_int2_equal_false";
 float8_lt_int2_equal_false 
----------------------------
 f
(1 row)

SELECT 15::float8 < 10::int2 AS "float8_lt_int2_false";
 float8_lt_int2_false 
----------------------
 f
(1 row)

SELECT 5::float8 < 10::int4 AS "float8_lt_int4_true";
 float8_lt_int4_true 
---------------------
 t
(1 row)

SELECT 10::float8 < 10::int4 AS "float8_lt_int4_equal_false";
 float8_lt_int4_equal_false 
----------------------------
 f
(1 row)

SELECT 15::float8 < 10::int4 AS "float8_lt_int4_false";
 float8_lt_int4_false 
----------------------
 f
(1 row)

SELECT 5::float8 < 10::int8 AS "float8_lt_int8_true";
 float8_lt_int8_true 
---------------------
 t
(1 row)

SELECT 10::float8 < 10::int8 AS "float8_lt_int8_equal_false";
 float8_lt_int8_equal_false 
----------------------------
 f
(1 row)

SELECT 15::float8 < 10::int8 AS "float8_lt_int8_false";
 float8_lt_int8_false 
----------------------
 f
(1 row)

-- Test 16: Greater than operator (>) with float4
SELECT 15::float4 > 10::int2 AS "float4_gt_int2_true";
 float4_gt_int2_true 
---------------------
 t
(1 row)

SELECT 10::float4 > 10::int2 AS "float4_gt_int2_equal_false";
 float4_gt_int2_equal_false 
----------------------------
 f
(1 row)

SELECT 5::float4 > 10::int2 AS "float4_gt_int2_false";
 float4_gt_int2_false 
----------------------
 f
(1 row)

SELECT 15::float4 > 10::int4 AS "float4_gt_int4_true";
 float4_gt_int4_true 
---------------------
 t
(1 row)

SELECT 10::float4 > 10::int4 AS "float4_gt_int4_equal_false";
 float4_gt_int4_equal_false 
----------------------------
 f
(1 row)

SELECT 5::float4 > 10::int4 AS "float4_gt_int4_false";
 float4_gt_int4_false 
----------------------
 f
(1 row)

SELECT 15::float4 > 10::int8 AS "float4_gt_int8_true";
 float4_gt_int8_true 
---------------------
 t
(1 row)

SELECT 10::float4 > 10::int8 AS "float4_gt_int8_equal_false";
 float4_gt_int8_equal_false 
----------------------------
 f
(1 row)

SELECT 5::float4 > 10::int8 AS "float4_gt_int8_false";
 float4_gt_int8_false 
----------------------
 f
(1 row)

-- Test 17: Greater than operator (>) with float8
SELECT 15::float8 > 10::int2 AS "float8_gt_int2_true";
 float8_gt_int2_true 
---------------------
 t
(1 row)

SELECT 10::float8 > 10::int2 AS "float8_gt_int2_equal_false";
 float8_gt_int2_equal_false 
----------------------------
 f
(1 row)

SELECT 5::float8 > 10::int2 AS "float8_gt_int2_false";
 float8_gt_int2_false 
----------------------
 f
(1 row)

SELECT 15::float8 > 10::int4 AS "float8_gt_int4_true";
 float8_gt_int4_true 
---------------------
 t
(1 row)

SELECT 10::float8 > 10::int4 AS "float8_gt_int4_equal_false";
 float8_gt_int4_equal_false 
----------------------------
 f
(1 row)

SELECT 5::float8 > 10::int4 AS "float8_gt_int4_false";
 float8_gt_int4_false 
----------------------
 f
(1 row)

SELECT 15::float8 > 10::int8 AS "float8_gt_int8_true";
 float8_gt_int8_true 
---------------------
 t
(1 row)

SELECT 10::float8 > 10::int8 AS "float8_gt_int8_equal_false";
 float8_gt_int8_equal_false 
----------------------------
 f
(1 row)

SELECT 5::float8 > 10::int8 AS "float8_gt_int8_false";
 float8_gt_int8_false 
----------------------
 f
(1 row)

-- Test 18: Less than or equal operator (<=) with float4 and float8
SELECT 5::float4 <= 10::int4 AS "float4_le_int4_less";
 float4_le_int4_less 
---------------------
 t
(1 row)

SELECT 10::float4 <= 10::int4 AS "float4_le_int4_equal";
 float4_le_int4_equal 
----------------------
 t
(1 row)

SELECT 15::float4 <= 10::int4 AS "float4_le_int4_false";
 float4_le_int4_false 
----------------------
 f
(1 row)

SELECT 5::float8 <= 10::int8 AS "float8_le_int8_less";
 float8_le_int8_less 
---------------------
 t
(1 row)

SELECT 10::float8 <= 10::int8 AS "float8_le_int8_equal";
 float8_le_int8_equal 
----------------------
 t
(1 row)

SELECT 15::float8 <= 10::int8 AS "float8_le_int8_false";
 float8_le_int8_false 
----------------------
 f
(1 row)

-- Test 19: Greater than or equal operator (>=) with float4 and float8
SELECT 15::float4 >= 10::int4 AS "float4_ge_int4_greater";
 float4_ge_int4_greater 
------------------------
 t
(1 row)

SELECT 10::float4 >= 10::int4 AS "float4_ge_int4_equal";
 float4_ge_int4_equal 
----------------------
 t
(1 row)

SELECT 5::float4 >= 10::int4 AS "float4_ge_int4_false";
 float4_ge_int4_false 
----------------------
 f
(1 row)

SELECT 15::float8 >= 10::int8 AS "float8_ge_int8_greater";
 float8_ge_int8_greater 
------------------------
 t
(1 row)

SELECT 10::float8 >= 10::int8 AS "float8_ge_int8_equal";
 float8_ge_int8_equal 
----------------------
 t
(1 row)

SELECT 5::float8 >= 10::int8 AS "float8_ge_int8_false";
 float8_ge_int8_false 
----------------------
 f
(1 row)

-- Test 20: Range operators with fractional values
SELECT 10.5::float4 < 11::int4 AS "float4_frac_lt_ceil_true";
 float4_frac_lt_ceil_true 
--------------------------
 t
(1 row)

SELECT 10.5::float4 < 10::int4 AS "float4_frac_lt_floor_false";
 float4_frac_lt_floor_false 
----------------------------
 f
(1 row)

SELECT 10.5::float4 > 10::int4 AS "float4_frac_gt_floor_true";
 float4_frac_gt_floor_true 
---------------------------
 t
(1 row)

SELECT 10.5::float4 > 11::int4 AS "float4_frac_gt_ceil_false";
 float4_frac_gt_ceil_false 
---------------------------
 f
(1 row)

SELECT 10.5::float8 <= 11::int8 AS "float8_frac_le_ceil_true";
 float8_frac_le_ceil_true 
--------------------------
 t
(1 row)

SELECT 10.5::float8 >= 10::int8 AS "float8_frac_ge_floor_true";
 float8_frac_ge_floor_true 
---------------------------
 t
(1 row)

-- Test 21: Range operators with negative values
SELECT (-10)::float4 < (-5)::int4 AS "float4_neg_lt_int4";
 float4_neg_lt_int4 
--------------------
 t
(1 row)

SELECT (-5)::float8 > (-10)::int8 AS "float8_neg_gt_int8";
 float8_neg_gt_int8 
--------------------
 t
(1 row)

-- Test 22: NaN and Infinity with range operators (NaN is treated as greater for ordering)
SELECT 'NaN'::float4 < 10::int4 AS "NaN_float4_lt_int4_false";
 NaN_float4_lt_int4_false 
--------------------------
 f
(1 row)

SELECT 'NaN'::float4 > 10::int4 AS "NaN_float4_gt_int4_true";
 NaN_float4_gt_int4_true 
-------------------------
 t
(1 row)

SELECT 'Infinity'::float4 > 10::int4 AS "Inf_float4_gt_int4_true";
 Inf_float4_gt_int4_true 
-------------------------
 t
(1 row)

SELECT '-Infinity'::float8 < 10::int8 AS "NegInf_float8_lt_int8_true";
 NegInf_float8_lt_int8_true 
----------------------------
 t
(1 row)

--
-- Phase 3: User Story 1 - Catalog Verification Tests (T012-T014a)
--
-- T012 [US1] Add pg_amop catalog verification query for float_ops btree (expect 95 entries)
SELECT COUNT(*) AS "float_ops_btree_operators"
FROM pg_amop
WHERE amopfamily = (SELECT oid FROM pg_opfamily WHERE opfname = 'float_ops' AND opfmethod = (SELECT oid FROM pg_am WHERE amname = 'btree'));
 float_ops_btree_operators 
---------------------------
                        95
(1 row)

-- T013 [US1] Remove duplicate float8_ops test (PostgreSQL only has one float_ops family)
-- This test is now covered by T012 above
-- T014 [US1] Add pg_amop catalog verification query for integer_ops btree float entries (expect 150 entries)
SELECT COUNT(*) AS "integer_ops_btree_operators"
FROM pg_amop
WHERE amopfamily = (SELECT oid FROM pg_opfamily WHERE opfname = 'integer_ops' AND opfmethod = (SELECT oid FROM pg_am WHERE amname = 'btree'));
 integer_ops_btree_operators 
-----------------------------
                         150
(1 row)

-- T014a [US1] Add pg_operator verification query to confirm MERGES property on equality operators
SELECT COUNT(*) AS "equality_ops_with_merges"
FROM pg_operator
WHERE oprname = '='
  AND (oprleft IN (SELECT oid FROM pg_type WHERE typname IN ('int2', 'int4', 'int8', 'float4', 'float8'))
       OR oprright IN (SELECT oid FROM pg_type WHERE typname IN ('int2', 'int4', 'int8', 'float4', 'float8')))
  AND oprcanmerge = true;
 equality_ops_with_merges 
--------------------------
                       28
(1 row)

--
-- Phase 4: User Story 2 - Transitivity Tests (T016-T020a)
--
-- T016 [US2] Add transitivity test for int4 = float4 = int4 chain
-- Create test scenario: if a = b and b = c, then a = c
SELECT
  (42::int4 = 42.0::float4) AS "int4_eq_float4",
  (42.0::float4 = 42::int4) AS "float4_eq_int4_reverse",
  (42::int4 = 42::int4) AS "int4_eq_int4_transitive"
WHERE 42::int4 = 42.0::float4 AND 42.0::float4 = 42::int4;
 int4_eq_float4 | float4_eq_int4_reverse | int4_eq_int4_transitive 
----------------+------------------------+-------------------------
 t              | t                      | t
(1 row)

-- T017 [US2] Add transitivity test for int8 = float8 = int8 chain
SELECT
  (1000000::int8 = 1000000.0::float8) AS "int8_eq_float8",
  (1000000.0::float8 = 1000000::int8) AS "float8_eq_int8_reverse",
  (1000000::int8 = 1000000::int8) AS "int8_eq_int8_transitive"
WHERE 1000000::int8 = 1000000.0::float8 AND 1000000.0::float8 = 1000000::int8;
 int8_eq_float8 | float8_eq_int8_reverse | int8_eq_int8_transitive 
----------------+------------------------+-------------------------
 t              | t                      | t
(1 row)

-- T018 [US2] Add NaN transitivity test (NaN = NaN, NaN > all non-NaN)
SELECT
  ('NaN'::float4 = 'NaN'::float4) AS "NaN_eq_NaN_float4",
  ('NaN'::float8 = 'NaN'::float8) AS "NaN_eq_NaN_float8",
  ('NaN'::float4 > 999999::int4) AS "NaN_gt_maxint",
  ('NaN'::float8 > 999999::int8) AS "NaN_gt_maxint8";
 NaN_eq_NaN_float4 | NaN_eq_NaN_float8 | NaN_gt_maxint | NaN_gt_maxint8 
-------------------+-------------------+---------------+----------------
 t                 | t                 | t             | t
(1 row)

-- T019 [US2] Add +/-Infinity ordering test (-Inf < all ints < +Inf)
SELECT
  ('-Infinity'::float4 < (-2147483648)::int4) AS "negInf_lt_minint4",
  ('Infinity'::float4 > 2147483647::int4) AS "posInf_gt_maxint4",
  ('-Infinity'::float8 < (-9223372036854775808)::int8) AS "negInf_lt_minint8",
  ('Infinity'::float8 > 9223372036854775807::int8) AS "posInf_gt_maxint8";
 negInf_lt_minint4 | posInf_gt_maxint4 | negInf_lt_minint8 | posInf_gt_maxint8 
-------------------+-------------------+-------------------+-------------------
 t                 | t                 | t                 | t
(1 row)

-- T020 [US2] Add precision boundary transitivity test (16777216 boundary for float4)
SELECT
  (16777216::int4 = 16777216::float4) AS "at_float4_limit_true",
  (16777217::int4 = 16777217::float4) AS "beyond_float4_limit_false",
  (9007199254740992::int8 = 9007199254740992::float8) AS "at_float8_limit_true",
  (9007199254740993::int8 = 9007199254740993::float8) AS "beyond_float8_limit_false";
 at_float4_limit_true | beyond_float4_limit_false | at_float8_limit_true | beyond_float8_limit_false 
----------------------+---------------------------+----------------------+---------------------------
 t                    | f                         | t                    | f
(1 row)

-- Create test table for transitive inference test
CREATE TEMPORARY TABLE transitivity_test (val int4);
INSERT INTO transitivity_test VALUES (42), (100), (200);
-- T020a [US2] Add EXPLAIN test for transitive inference (verify planner simplifies chained conditions)
EXPLAIN (COSTS false)
SELECT * FROM transitivity_test t
WHERE t.val = 42::float4
  AND 42::float4 = 42::int4
  AND 42::int4 = t.val;
           QUERY PLAN            
---------------------------------
 Seq Scan on transitivity_test t
   Filter: (val = 42)
(2 rows)

-- Cleanup
DROP TABLE transitivity_test;
