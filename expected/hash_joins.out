-- Test hash joins with cross-type equality operators
-- This file tests that our operators support hash join optimization
\echo '=== Test 1: Hash Join with numeric = int4 ==='
=== Test 1: Hash Join with numeric = int4 ===
CREATE TEMP TABLE hash_numeric (val numeric, id int);
CREATE TEMP TABLE hash_int4 (val int4, id int);
INSERT INTO hash_numeric SELECT i::numeric, i FROM generate_series(1, 100) i;
INSERT INTO hash_int4 SELECT i, i FROM generate_series(1, 100) i;
-- Force hash join
SET enable_nestloop = off;
SET enable_mergejoin = off;
EXPLAIN (COSTS OFF) 
SELECT COUNT(*) FROM hash_numeric n JOIN hash_int4 i ON n.val = i.val;
                  QUERY PLAN                  
----------------------------------------------
 Aggregate
   ->  Hash Join
         Hash Cond: (i.val = n.val)
         ->  Seq Scan on hash_int4 i
         ->  Hash
               ->  Seq Scan on hash_numeric n
(6 rows)

SELECT COUNT(*) FROM hash_numeric n JOIN hash_int4 i ON n.val = i.val;
 count 
-------
   100
(1 row)

\echo '=== Test 1b: Hash Aggregate with GROUP BY ==='
=== Test 1b: Hash Aggregate with GROUP BY ===
EXPLAIN (COSTS OFF)
SELECT i.val, COUNT(*) FROM hash_numeric n JOIN hash_int4 i ON n.val = i.val GROUP BY i.val;
                  QUERY PLAN                  
----------------------------------------------
 HashAggregate
   Group Key: i.val
   ->  Hash Join
         Hash Cond: (i.val = n.val)
         ->  Seq Scan on hash_int4 i
         ->  Hash
               ->  Seq Scan on hash_numeric n
(7 rows)

SELECT i.val, COUNT(*) FROM hash_numeric n JOIN hash_int4 i ON n.val = i.val GROUP BY i.val ORDER BY i.val LIMIT 10;
 val | count 
-----+-------
   1 |     1
   2 |     1
   3 |     1
   4 |     1
   5 |     1
   6 |     1
   7 |     1
   8 |     1
   9 |     1
  10 |     1
(10 rows)

EXPLAIN (COSTS OFF)
SELECT i.val, n.val, COUNT(*) FROM hash_numeric n JOIN hash_int4 i ON n.val = i.val GROUP BY i.val, n.val;
                  QUERY PLAN                  
----------------------------------------------
 HashAggregate
   Group Key: i.val
   ->  Hash Join
         Hash Cond: (i.val = n.val)
         ->  Seq Scan on hash_int4 i
         ->  Hash
               ->  Seq Scan on hash_numeric n
(7 rows)

SELECT i.val, n.val, COUNT(*) FROM hash_numeric n JOIN hash_int4 i ON n.val = i.val GROUP BY i.val, n.val ORDER BY i.val LIMIT 10;
 val | val | count 
-----+-----+-------
   1 |   1 |     1
   2 |   2 |     1
   3 |   3 |     1
   4 |   4 |     1
   5 |   5 |     1
   6 |   6 |     1
   7 |   7 |     1
   8 |   8 |     1
   9 |   9 |     1
  10 |  10 |     1
(10 rows)

\echo '=== Test 1c: Hash Aggregate with DISTINCT ==='
=== Test 1c: Hash Aggregate with DISTINCT ===
EXPLAIN (COSTS OFF)
SELECT DISTINCT i.val FROM hash_numeric n JOIN hash_int4 i ON n.val = i.val;
                  QUERY PLAN                  
----------------------------------------------
 HashAggregate
   Group Key: i.val
   ->  Hash Join
         Hash Cond: (i.val = n.val)
         ->  Seq Scan on hash_int4 i
         ->  Hash
               ->  Seq Scan on hash_numeric n
(7 rows)

SELECT DISTINCT i.val FROM hash_numeric n JOIN hash_int4 i ON n.val = i.val ORDER BY i.val LIMIT 10;
 val 
-----
   1
   2
   3
   4
   5
   6
   7
   8
   9
  10
(10 rows)

EXPLAIN (COSTS OFF)
SELECT DISTINCT i.val, n.val FROM hash_numeric n JOIN hash_int4 i ON n.val = i.val;
                  QUERY PLAN                  
----------------------------------------------
 HashAggregate
   Group Key: i.val
   ->  Hash Join
         Hash Cond: (i.val = n.val)
         ->  Seq Scan on hash_int4 i
         ->  Hash
               ->  Seq Scan on hash_numeric n
(7 rows)

SELECT DISTINCT i.val, n.val FROM hash_numeric n JOIN hash_int4 i ON n.val = i.val ORDER BY i.val LIMIT 10;
 val | val 
-----+-----
   1 |   1
   2 |   2
   3 |   3
   4 |   4
   5 |   5
   6 |   6
   7 |   7
   8 |   8
   9 |   9
  10 |  10
(10 rows)

\echo '=== Test 2: Hash Join with float8 = int8 ==='
=== Test 2: Hash Join with float8 = int8 ===
CREATE TEMP TABLE hash_float8 (val float8);
CREATE TEMP TABLE hash_int8 (val int8);
INSERT INTO hash_float8 SELECT i::float8 FROM generate_series(1, 50) i;
INSERT INTO hash_int8 SELECT i FROM generate_series(1, 50) i;
EXPLAIN (COSTS OFF)
SELECT COUNT(*) FROM hash_float8 f JOIN hash_int8 i ON f.val = i.val;
                QUERY PLAN                 
-------------------------------------------
 Aggregate
   ->  Hash Join
         Hash Cond: (f.val = i.val)
         ->  Seq Scan on hash_float8 f
         ->  Hash
               ->  Seq Scan on hash_int8 i
(6 rows)

SELECT COUNT(*) FROM hash_float8 f JOIN hash_int8 i ON f.val = i.val;
 count 
-------
    50
(1 row)

\echo '=== Test 2b: Hash Aggregate with GROUP BY ==='
=== Test 2b: Hash Aggregate with GROUP BY ===
EXPLAIN (COSTS OFF)
SELECT i.val, COUNT(*) FROM hash_float8 f JOIN hash_int8 i ON f.val = i.val GROUP BY i.val;
                QUERY PLAN                 
-------------------------------------------
 HashAggregate
   Group Key: i.val
   ->  Hash Join
         Hash Cond: (f.val = i.val)
         ->  Seq Scan on hash_float8 f
         ->  Hash
               ->  Seq Scan on hash_int8 i
(7 rows)

SELECT i.val, COUNT(*) FROM hash_float8 f JOIN hash_int8 i ON f.val = i.val GROUP BY i.val ORDER BY i.val LIMIT 10;
 val | count 
-----+-------
   1 |     1
   2 |     1
   3 |     1
   4 |     1
   5 |     1
   6 |     1
   7 |     1
   8 |     1
   9 |     1
  10 |     1
(10 rows)

EXPLAIN (COSTS OFF)
SELECT i.val, f.val, COUNT(*) FROM hash_float8 f JOIN hash_int8 i ON f.val = i.val GROUP BY i.val, f.val;
                QUERY PLAN                 
-------------------------------------------
 HashAggregate
   Group Key: i.val, f.val
   ->  Hash Join
         Hash Cond: (f.val = i.val)
         ->  Seq Scan on hash_float8 f
         ->  Hash
               ->  Seq Scan on hash_int8 i
(7 rows)

SELECT i.val, f.val, COUNT(*) FROM hash_float8 f JOIN hash_int8 i ON f.val = i.val GROUP BY i.val, f.val ORDER BY i.val LIMIT 10;
 val | val | count 
-----+-----+-------
   1 |   1 |     1
   2 |   2 |     1
   3 |   3 |     1
   4 |   4 |     1
   5 |   5 |     1
   6 |   6 |     1
   7 |   7 |     1
   8 |   8 |     1
   9 |   9 |     1
  10 |  10 |     1
(10 rows)

\echo '=== Test 2c: Hash Aggregate with DISTINCT ==='
=== Test 2c: Hash Aggregate with DISTINCT ===
EXPLAIN (COSTS OFF)
SELECT DISTINCT i.val FROM hash_float8 f JOIN hash_int8 i ON f.val = i.val;
                QUERY PLAN                 
-------------------------------------------
 HashAggregate
   Group Key: i.val
   ->  Hash Join
         Hash Cond: (f.val = i.val)
         ->  Seq Scan on hash_float8 f
         ->  Hash
               ->  Seq Scan on hash_int8 i
(7 rows)

SELECT DISTINCT i.val FROM hash_float8 f JOIN hash_int8 i ON f.val = i.val ORDER BY i.val LIMIT 10;
 val 
-----
   1
   2
   3
   4
   5
   6
   7
   8
   9
  10
(10 rows)

EXPLAIN (COSTS OFF)
SELECT DISTINCT i.val, f.val FROM hash_float8 f JOIN hash_int8 i ON f.val = i.val;
                QUERY PLAN                 
-------------------------------------------
 HashAggregate
   Group Key: i.val, f.val
   ->  Hash Join
         Hash Cond: (f.val = i.val)
         ->  Seq Scan on hash_float8 f
         ->  Hash
               ->  Seq Scan on hash_int8 i
(7 rows)

SELECT DISTINCT i.val, f.val FROM hash_float8 f JOIN hash_int8 i ON f.val = i.val ORDER BY i.val LIMIT 10;
 val | val 
-----+-----
   1 |   1
   2 |   2
   3 |   3
   4 |   4
   5 |   5
   6 |   6
   7 |   7
   8 |   8
   9 |   9
  10 |  10
(10 rows)

\echo '=== Test 3: Hash Join with float4 = int2 ==='
=== Test 3: Hash Join with float4 = int2 ===
CREATE TEMP TABLE hash_float4 (val float4);
CREATE TEMP TABLE hash_int2 (val int2);
INSERT INTO hash_float4 SELECT i::float4 FROM generate_series(1, 20) i;
INSERT INTO hash_int2 SELECT i::int2 FROM generate_series(1, 20) i;
EXPLAIN (COSTS OFF)
SELECT COUNT(*) FROM hash_float4 f JOIN hash_int2 i ON f.val = i.val;
                 QUERY PLAN                  
---------------------------------------------
 Aggregate
   ->  Hash Join
         Hash Cond: (i.val = f.val)
         ->  Seq Scan on hash_int2 i
         ->  Hash
               ->  Seq Scan on hash_float4 f
(6 rows)

SELECT COUNT(*) FROM hash_float4 f JOIN hash_int2 i ON f.val = i.val;
 count 
-------
    20
(1 row)

\echo '=== Test 3c: Hash Aggregate with DISTINCT ==='
=== Test 3c: Hash Aggregate with DISTINCT ===
EXPLAIN (COSTS OFF)
SELECT DISTINCT i.val FROM hash_float4 f JOIN hash_int2 i ON f.val = i.val;
                 QUERY PLAN                  
---------------------------------------------
 HashAggregate
   Group Key: i.val
   ->  Hash Join
         Hash Cond: (i.val = f.val)
         ->  Seq Scan on hash_int2 i
         ->  Hash
               ->  Seq Scan on hash_float4 f
(7 rows)

SELECT DISTINCT i.val FROM hash_float4 f JOIN hash_int2 i ON f.val = i.val ORDER BY i.val LIMIT 10;
 val 
-----
   1
   2
   3
   4
   5
   6
   7
   8
   9
  10
(10 rows)

EXPLAIN (COSTS OFF)
SELECT DISTINCT i.val, f.val FROM hash_float4 f JOIN hash_int2 i ON f.val = i.val;
                 QUERY PLAN                  
---------------------------------------------
 HashAggregate
   Group Key: i.val, f.val
   ->  Hash Join
         Hash Cond: (i.val = f.val)
         ->  Seq Scan on hash_int2 i
         ->  Hash
               ->  Seq Scan on hash_float4 f
(7 rows)

SELECT DISTINCT i.val, f.val FROM hash_float4 f JOIN hash_int2 i ON f.val = i.val ORDER BY i.val LIMIT 10;
 val | val 
-----+-----
   1 |   1
   2 |   2
   3 |   3
   4 |   4
   5 |   5
   6 |   6
   7 |   7
   8 |   8
   9 |   9
  10 |  10
(10 rows)

\echo '=== Test 3b: Hash Aggregate with GROUP BY ==='
=== Test 3b: Hash Aggregate with GROUP BY ===
EXPLAIN (COSTS OFF)
SELECT i.val, COUNT(*) FROM hash_float4 f JOIN hash_int2 i ON f.val = i.val GROUP BY i.val;
                 QUERY PLAN                  
---------------------------------------------
 HashAggregate
   Group Key: i.val
   ->  Hash Join
         Hash Cond: (i.val = f.val)
         ->  Seq Scan on hash_int2 i
         ->  Hash
               ->  Seq Scan on hash_float4 f
(7 rows)

SELECT i.val, COUNT(*) FROM hash_float4 f JOIN hash_int2 i ON f.val = i.val GROUP BY i.val ORDER BY i.val LIMIT 10;
 val | count 
-----+-------
   1 |     1
   2 |     1
   3 |     1
   4 |     1
   5 |     1
   6 |     1
   7 |     1
   8 |     1
   9 |     1
  10 |     1
(10 rows)

EXPLAIN (COSTS OFF)
SELECT i.val, f.val, COUNT(*) FROM hash_float4 f JOIN hash_int2 i ON f.val = i.val GROUP BY i.val, f.val;
                 QUERY PLAN                  
---------------------------------------------
 HashAggregate
   Group Key: i.val, f.val
   ->  Hash Join
         Hash Cond: (i.val = f.val)
         ->  Seq Scan on hash_int2 i
         ->  Hash
               ->  Seq Scan on hash_float4 f
(7 rows)

SELECT i.val, f.val, COUNT(*) FROM hash_float4 f JOIN hash_int2 i ON f.val = i.val GROUP BY i.val, f.val ORDER BY i.val LIMIT 10;
 val | val | count 
-----+-----+-------
   1 |   1 |     1
   2 |   2 |     1
   3 |   3 |     1
   4 |   4 |     1
   5 |   5 |     1
   6 |   6 |     1
   7 |   7 |     1
   8 |   8 |     1
   9 |   9 |     1
  10 |  10 |     1
(10 rows)

\echo '=== Test 4: Verify HASHES property ==='
=== Test 4: Verify HASHES property ===
-- Check that our equality operators have the HASHES property
SELECT oprname, oprleft::regtype, oprright::regtype, oprcanhash
FROM pg_operator
WHERE oprname = '='
  AND (oprleft::regtype::text = 'numeric' AND oprright::regtype::text IN ('smallint', 'integer', 'bigint')
       OR oprleft::regtype::text IN ('smallint', 'integer', 'bigint') AND oprright::regtype::text = 'numeric')
ORDER BY oprleft, oprright;
 oprname | oprleft  | oprright | oprcanhash 
---------+----------+----------+------------
 =       | bigint   | numeric  | t
 =       | smallint | numeric  | t
 =       | integer  | numeric  | t
 =       | numeric  | bigint   | t
 =       | numeric  | smallint | t
 =       | numeric  | integer  | t
(6 rows)

\echo '=== Test 5: Hash consistency check ==='
=== Test 5: Hash consistency check ===
-- Verify that equal values hash consistently across types
SELECT hash_int4_as_numeric(10) = hash_int4_as_numeric(10) AS int4_consistent;
 int4_consistent 
-----------------
 t
(1 row)

SELECT hash_int8_as_numeric(100) = hash_int8_as_numeric(100) AS int8_consistent;
 int8_consistent 
-----------------
 t
(1 row)

SELECT hash_int4_as_float8(10) = hash_int4_as_float8(10) AS float8_consistent;
 float8_consistent 
-------------------
 t
(1 row)

